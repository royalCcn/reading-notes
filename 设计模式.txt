设计模式简介
	设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石
设计模式的类型
	总共有 23 种设计模式。
	这些模式可以分为三大类：
		创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。
		当然，我们还会讨论另一类设计模式：J2EE 设计模式。	
	创建型模式
		这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。	
			工厂模式（Factory Pattern）
			抽象工厂模式（Abstract Factory Pattern）
			单例模式（Singleton Pattern）
			建造者模式（Builder Pattern）
			原型模式（Prototype Pattern）
	结构型模式
		这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。	
			适配器模式（Adapter Pattern）
			桥接模式（Bridge Pattern）
			过滤器模式（Filter、Criteria Pattern）
			组合模式（Composite Pattern）
			装饰器模式（Decorator Pattern）
			外观模式（Facade Pattern）
			享元模式（Flyweight Pattern）
			代理模式（Proxy Pattern）
	行为型模式
		这些设计模式特别关注对象之间的通信。	
			责任链模式（Chain of Responsibility Pattern）
			命令模式（Command Pattern）
			解释器模式（Interpreter Pattern）
			迭代器模式（Iterator Pattern）
			中介者模式（Mediator Pattern）
			备忘录模式（Memento Pattern）
			观察者模式（Observer Pattern）
			状态模式（State Pattern）
			空对象模式（Null Object Pattern）
			策略模式（Strategy Pattern）
			模板模式（Template Pattern）
			访问者模式（Visitor Pattern）
	J2EE 模式
		这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。	
			MVC 模式（MVC Pattern）
			业务代表模式（Business Delegate Pattern）
			组合实体模式（Composite Entity Pattern）
			数据访问对象模式（Data Access Object Pattern）
			前端控制器模式（Front Controller Pattern）
			拦截过滤器模式（Intercepting Filter Pattern）
			服务定位器模式（Service Locator Pattern）
			传输对象模式（Transfer Object Pattern）	
设计模式的六大原则
	1、开闭原则（Open Close Principle）
		开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
	2、里氏代换原则（Liskov Substitution Principle）
		里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
	3、依赖倒转原则（Dependence Inversion Principle）
		这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。
	4、接口隔离原则（Interface Segregation Principle）
		这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。
	5、迪米特法则，又称最少知道原则（Demeter Principle）
		最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
	6、合成复用原则（Composite Reuse Principle）
		合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。	
		
工厂模式
	工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
	在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。		
		
	介绍
		意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
		主要解决：主要解决接口选择的问题。
		何时使用：我们明确地计划不同条件下创建不同实例时。
		如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。
		关键代码：创建过程在其子类执行。	
		优点： 	1、一个调用者想创建一个对象，只要知道其名称就可以了。 
				2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
				3、屏蔽产品的具体实现，调用者只关心产品的接口。
		缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。
		使用场景： 	1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 
					2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 
					3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。
		注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。
		
抽象工厂模式
	抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
	在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

	介绍
		意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
		主要解决：主要解决接口选择的问题。
		何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。
		如何解决：在一个产品族里面，定义多个产品。
		关键代码：在一个工厂里聚合多个同类产品。
		优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。
		缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。
		使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。
		注意事项：产品族难扩展，产品等级易扩展。		
		
单例模式
	单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
	这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
		注意：
			1、单例类只能有一个实例。
			2、单例类必须自己创建自己的唯一实例。
			3、单例类必须给所有其他对象提供这一实例。
	
	介绍
		意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
		主要解决：一个全局使用的类频繁地创建与销毁。
		何时使用：当您想控制实例数目，节省系统资源的时候。
		如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。
		关键代码：构造函数是私有的。
		优点：
			1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
			2、避免对资源的多重占用（比如写文件操作）。
		缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。
		使用场景：
			1、要求生产唯一序列号。
			2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
			3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。
	单例模式的几种实现方式
		单例模式的实现有多种方式，如下所示：
			1、懒汉式，线程不安全
				是否 Lazy 初始化：是
				是否多线程安全：否
				实现难度：易
				描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。
				这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。	
			2、懒汉式，线程安全
				是否 Lazy 初始化：是
				是否多线程安全：是
				实现难度：易
				描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。
				优点：第一次调用才初始化，避免内存浪费。
				缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。
				getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。
			3、饿汉式
				是否 Lazy 初始化：否
				是否多线程安全：是
				实现难度：易
				描述：这种方式比较常用，但容易产生垃圾对象。
				优点：没有加锁，执行效率会提高。
				缺点：类加载时就初始化，浪费内存。
				它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。
			4、双检锁/双重校验锁（DCL，即 double-checked locking）
				JDK 版本：JDK1.5 起
				是否 Lazy 初始化：是
				是否多线程安全：是
				实现难度：较复杂
				描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
				getInstance() 的性能对应用程序很关键。
			5、登记式/静态内部类
				是否 Lazy 初始化：是
				是否多线程安全：是
				实现难度：一般
				描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。
				这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。
			6、枚举
				JDK 版本：JDK1.5 起
				是否 Lazy 初始化：否
				是否多线程安全：是
				实现难度：易
				描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。
				这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。
				不能通过 reflection attack 来调用私有构造方法。
		经验之谈：
			一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。
			只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。
			如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。
			如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。
		
建造者模式
	建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
	一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

	介绍
		意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
		主要解决：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
		何时使用：一些基本部件不会变，而其组合经常变化的时候。
		如何解决：将变与不变分离开。
		关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。
		应用实例： 
			1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 
			2、JAVA 中的 StringBuilder。
		优点： 
			1、建造者独立，易扩展。 
			2、便于控制细节风险。
		缺点： 
			1、产品必须有共同点，范围有限制。 
			2、如内部变化复杂，会有很多的建造类。
		使用场景： 
			1、需要生成的对象具有复杂的内部结构。 
			2、需要生成的对象内部属性本身相互依赖。
		注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。		
		
原型模式
	原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
	这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

	介绍
		意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
		主要解决：在运行期建立和删除原型。
		何时使用： 
			1、当一个系统应该独立于它的产品创建，构成和表示时。 
			2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
		如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。
		关键代码： 
			1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 
			2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。
		应用实例： 
			1、细胞分裂。 
			2、JAVA 中的 Object clone() 方法。
		优点： 
			1、性能提高。 
			2、逃避构造函数的约束。
		缺点： 
			1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 
			2、必须实现 Cloneable 接口。
		使用场景： 
			1、资源优化场景。 
			2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 
			3、性能和安全要求的场景。 
			4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 
			5、一个对象多个修改者的场景。 
			6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 
			7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。
		注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。		
		
适配器模式
	适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。
	这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。
	我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。

	介绍
		意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
		主要解决：主要解决在
		何时使用： 
			1、系统需要使用现有的类，而此类的接口不符合系统的需要。 
			2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 
			3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）
		如何解决：继承或依赖（推荐）。
		关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。
		应用实例： 
			1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 
			2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 
			3、在 LINUX 上运行 WINDOWS 程序。 
			4、JAVA 中的 jdbc。
		优点： 
			1、可以让任何两个没有关联的类一起运行。 
			2、提高了类的复用。 
			3、增加了类的透明度。 
			4、灵活性好
		缺点： 
			1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 
			2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。
		使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式
		注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。		
		
桥接模式
	桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
	这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。
	我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。

	介绍
		意图：将抽象部分与实现部分分离，使它们都可以独立的变化。
		主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。
		何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。
		如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。
		关键代码：抽象类依赖实现类。
		应用实例： 
			1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 
			2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。
		优点： 
			1、抽象和实现的分离。 
			2、优秀的扩展能力。 
			3、实现细节对客户透明。
		缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。
		使用场景： 
			1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 
			2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 
			3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。
		注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。		
		
过滤器模式
	过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，
	这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。
	这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。		
		
		
		
		
		
		
		
		
SELECT 
c.id,
tor.store_id AS storeId,
tor.dealer_id AS dealerId, 

c.`code` AS cashierNo,  --流水编号
tor.`code` AS orderCode,--订单编号
COALESCE(c.pay_name,'') AS payName,--付款人
COALESCE(c.pay_role,'') AS payRole,--付款人角色
COALESCE(c.pay_from,'') AS payFrom,--付款来源  （本只支付、代付）
COALESCE(org.org_name,'') AS orgName,--门店
c.cashier_amount AS cashierAmount,--流水金额	
COALESCE(c.payee_name,'') AS payeeName,--收款人名称
COALESCE(c.payee_date,'') AS payeeDate,--收款时间
CASE c.cashier_type WHEN 0 THEN '定金' WHEN 1 THEN '货款' WHEN 2 THEN '退款' END AS cashierTypeText,--收款类型；0-定金；1-货款  
dpw.name AS cashierWayText,  --支付方式
(SELECT GROUP_CONCAT(CONCAT(employee_name,';',tc_split, ';',yj_split)) FROM yk_track_cashier_split WHERE cashier_id = c.id ) AS 'splitEmployee',--拆分
CASE c.`comfirm_status` WHEN  0 THEN '待确认' WHEN 1 THEN '已确认' WHEN 2 THEN '已取消' END AS comfirmStatusText,--流水状态
COALESCE(c.remark,'') AS remark,--流水备注

CASE c.`status` WHEN  0 THEN '未核销' WHEN 1 THEN '部分核销' WHEN 2 THEN '全部核销' WHEN  3 THEN '已取消' END AS statusText,

(SELECT REAL_NAME FROM ykee_org.yk_employee WHERE id = c.created_by) AS createdName,--记录人
COALESCE(c.created_date,'') AS createdDate,--记录时间
COALESCE((SELECT REAL_NAME FROM ykee_org.yk_employee WHERE id = c.comfirm_Id),'') AS comfirmName,--确认收款人
COALESCE(c.comfirm_date,'') AS comfirmDate,--确认时间
COALESCE(c.comfirm_status,'') AS comfirmStatus,--确认状态0-待确认  1-已确认   2-已取消
COALESCE(c.comfirm_remark,'') AS comfirmRemark,--确认备注
    
    
	
	c.cashier_type AS cashierType, 
    DATE_FORMAT(c.created_date,'%Y-%m-%d') AS cashierDate,
	c.`status`,
    
    https://crmdev.skshu.com.cn/xmanager/YkReport/track/exportTrackDeal?
	page=1&start=0&limit=10
	&sort=[{%22property%22:%22lastUpdatedDate%22,%22direction%22:%22DESC%22}]
	&filter=&firefoxexplorer=1&_dc=0.5301508752577209
    
    yc.`name` AS customerName,c.receiver_type AS receiverType,
    
    
	COALESCE(c.delivery,'') AS delivery,
	
	
	
    COALESCE(c.created_by,'') AS createdBy,
    ( SELECT COUNT(0) FROM yk_track_order_cashier WHERE cashier_id =c.id ) AS releaseOrderCount,
    ( SELECT NAME  FROM member_type WHERE CODE =c.pay_role ) AS roleName
    
    
    FROM yk_track_cashier AS  c
    LEFT JOIN yk_track_order_cashier AS  oc ON oc.cashier_id = c.id
    LEFT JOIN yk_track_order AS tor ON oc.order_id = tor.id
    LEFT JOIN yk_member AS yc ON c.member_id = yc.id
    LEFT JOIN ykee_org.yk_org AS org ON tor.store_id = org.ID
    LEFT JOIN ykee_product.dic_pay_way dpw ON dpw.code = c.cashier_way
    LEFT JOIN ykee_org.yk_employee ye ON ye.id = c.created_by
      WHERE c.remove_flag = 0
		
		
		dms订单保存、同步
		
		
		listServiceItemFeeByOrderId
		
		updateByPrimaryKeySelective
		
		
		/api/v2/dms/product/listPc  产品
		dms_profile_item		额外费用    proGoodsMapper.findServiceItemFeeList
		
		
		
		退货，库存处理器
		
		
		
		
		
		
		