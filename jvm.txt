跨语言平台
	jvm只关心字节码文件，各大平台都能经过编译后置于jvm运行
	虚拟机类型：
		1.系统虚拟机
		2.程序虚拟机
	概念：
		Java虚拟机就事二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令
	特点：
		1.一次编译，处处运行
		2.自动内存管理
		3.自动垃圾回收功能
	整体结构：
		1.class loader（类装载器）
			加载class文件（汇编语言）
		2.runtime data area（内存区）
			运行class文件
		3.execution engine（执行引擎）
			将高级程序语言解析/编译成机器语言执行
	架构模型：
		1.基于栈的指令集架构（内存）
			跨平台性、指令集小但指令多、执行性能比寄存器差
		2.基于寄存器的指令集架构（cpu）
	生命周期：
		1.启动
			通过引导类加载器（bootstrap class loader）创建一个初始类来完成
		2.执行
			1.清晰的任务：执行Java程序
			2.程序开始才开始，程序结束就停止
			3.执行Java程序，实际是在执行一个叫做Java虚拟机的一个进程
		3.退出
			1.程序执行完成
			2.程序出现异常结束
			3.条用system.exit/runtime结束
	HotSpot VM（热点代码探测技术）
		默认虚拟机
		特点：
			1.通过计数器找到最具编译价值代码（热点代码），触发即时编译或栈上替换
			2.通过解析器与编译器协同工作，在最优化的程序响应时间（解析器特点）与最佳执行性能（编译器特点）中取得平衡
	类加载器子系统
		作用：
			1.负责从文件系统/网络中加载class文件，class文件在文件开头有特定的文件标识
			2.class loader只负责class文件的加载，至于它是否运行，则由execution engine（执行引擎）决定
			3.加载的类信息存放于一块称为方法去区的内存空间，除了类的信息外，方法区还有存放运行时常量信息，可能还包括字符串字面量和数字常量
		过程：
			加载 - 链接（验证 - 准备 - 解析） - 初始化
			1.加载（loader）
				1.通过一个类的全限定名获取定义此类的二进制字节流
				2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
				3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口
			2.验证（verify）
				1.目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，
				  不会危害虚拟机自身安全
				2.主要包含四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证
				3.准备（prepare）
					1.为类变量分配并且设置该类变量的默认初始值，即零值
					2.这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化
					3.这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量会随着对象一部分配到Java堆中
				4.解析（resolve）
					1.将常量池内的符号引用转换为直接引用的过程
					2.事实上，解析操作往往会伴随Jvm在执行完初始化后再执行
			3.初始化（clinit）
				1.执行类构造器方法<clinit>（）的过程，这个方法不需要定义，是由javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来
				  主要是静态static的初始化	
				2.<clinit>（）是虚拟机视角下的<init>，class的构造才是init（）的方法
		分类：
			1.引导类加载器（bootstrap classloader）
				Java核心类通过引导加载器加载
			2.自定义类加载器（user-defined classloader）	
				继承classloader的一切类加载器、一般自定义的class类都是通过系统加载器加载（自定义加载器一种）	
		双亲委派机制：
			工作原理：
				把请求交由父类加载器处理，是一种任务委派模式。如果父类加载器加载不了，则由自定义加载器加载
			注意：
				在Jvm中表示两个class对象是否为同一个类存在两个必要条件：
					1.类的完整类名必须一致，包含包名
					2.加载这个类的classloader（指classloader实例对象）必须相同
		类加载器的引用：
			Jvm必须知道一个类是由启动加载器加载/自定义加载器加载。
			如果一个类是由自定义加载器加载，那么Jvm将这个类加载器的一个引用作为类信息保存到方法区。
			当解析一个类到另一个类的引用时，Jvm需要保证这两个类的加载器相同。
		类的主动使用和被动使用（加载）：
			1.主动使用（加载）
				创建类的实例、反射、类的静态方法
					
	
	运行时数据区（runtime data area）：
		组成：
			1.方法区（method area）
			2.堆区（heap）
			3.程序计算器（program counter register）
			4.本地方法栈（native method stack）
			5.虚拟机栈（Java virtual machine stack）
			
			注意：	
				1.每个线程独立包括程序计数器、栈、本地栈
				2.线程间共享堆/堆区、堆外内存/方法区（永久代/元空间（方法区）、代码缓存），即方法区（95%数据）和堆区（5%数据）
		线程：
			线程是一个程序里的运行单元，Jvm允许一个应用有多个线程
			在hotspot Jvm里，每个线程都与操作系统的本地线程直接映射
				即：当一个Java线程准备好执行后，此时一个操作系统的本地线程也同时创建，
					Java线程执行终止后，本地线程也会被回收
			操作系统负责所以线程的安排调度到任何一个可用的cpu上，一旦本地线程初始化成功，它就会调用Java线程中的run()方法。
			
			类型：
				虚拟机线程
				周期任务线程
				GC线程
				编译线程
				信号调度线程
			注意：可用jconsole或者任何一个调试工具，都可查看后台线程
					
		程序计算器（program counter register）
			别名：Jvm中的程序计数寄存器、指令计数器、程序钩子
				并非广义上所指的物理寄存器，是对物理pc寄存器的一种抽象模拟
			作用：	
				寄存器存储下一条指令的地址，cpu只有把数据转载到寄存器才能运行
			特点：	
				不存在GC（垃圾回收），也不存在OOM（异常）
		
		虚拟机栈
			概述：
				栈：是解决运行问题，即程序如何运行/如何处理数据
				堆：是解决数据存储问题，即数据怎么放、放在哪儿
				Java虚拟机栈，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧（对应Java方法）
					1.线程私有
					2.生命周期与线程一致
					作用：
						主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果
						并参与方法的调用和返回
					特点：
						栈是一种快速有效的分配存储方式，访问速度尽次于程序计数器
						Jvm直接对Java栈的操作只有两个：
							1.每个方法执行，伴随着进栈（入栈、压栈）
							2.执行结束后的出栈工作
							3.不存在GC（垃圾回收），存在OOM（异常）
			栈OOM（异常）类型：
				Java虚拟机规范允许Java栈的大小是动态或固定大小
					1.如果采用固定大小的Java虚拟机栈，如果线程请求分配的栈容量超过
						Java虚拟机栈允许的最大容量，Java虚拟机将会抛出StackOverflowError异常
					2.如果Java虚拟机栈可以动态拓展，并且在尝试拓展的时候无法申请到足够
						的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，
						Java虚拟机将会抛出一个OutOfMemoeyError异常
			栈中存储什么：
				1.每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在
				2.在每个线程上正在执行的每个方法都各自对应一个栈帧
				3.栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息
			栈运行原理：
				1.遵循“先进后出”原则
				2.在一个活动线程中，一个时间点只有一个活动的栈帧（当前栈帧）
					对应的方法称为当前方法，对应的类称为当前类
				3.执行引擎运行的所有字节码指令只针对当前栈帧进行操作
				4.如果在该方法中调用了其他方法，对应新的栈帧会被创建出来，放在栈的顶端
					成为新的当前帧
				5.不同线程中所包含的栈帧不允许存在相互引用，即不可能在一个栈帧中引用另一个线程的栈帧
				6.如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果
					给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧
				7.Java方法返回函数的两种方式：
					1.正常函数返回，使用return指令
					2.抛出异常
					注意：不论哪种方式，都会导致栈帧被弹出
			栈桢内部结构：
				组成：
					1.局部变量表（Local Variable）
					2.操作数栈（Operand Stack）/表达式栈
					3.动态链接（Dynamic Linking）/指向运行时常量池的方法引用
					4.方法返回地址（Return Address）/方法正常退出或者异常退出定义
					5.一些附加信息
				
				局部变量表：
					1.又名局部变量表、本地变量表
					2.定义为一个数字数组，主要用于存储方法参数 + 定义在方法体内的局部变量
						数据类型包括基本数据类型、对象引用等
					3.它是建立在线程的栈上的，是线程私有数据，因此不存在数据安全问题
					4.局部变量表所需的容量大小是在编译期确定下来的
					5.里的变量只在当前方法有效
					
					变量槽（slot）：
						1.局部变量表最基本的存储单元
						2.可存放编译期可知的各种基本数据类型、引用类型等
						3.32位以内的类型只占一个slot、64位的类型（long、double）占两个slot
						4.构造方法 + 非静态方法，默认有个this变量并且存放在第一个
						5.slot重复利用：当变量作用域到了，其slot位置给其他变量占用，以节约资源
						6.局部变量必须初始化
				操作数栈（Operand Stack）
					栈：可以使用数组/链表来表现
					1.后进先出
					2.只有入栈（push）、出栈（pop）
					3.主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
					4.当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来
						这个方法的操作数是空的
					5.每个操作数栈都会有一个明确的栈深度（数组长度表示）用于存储值
						其值在编译期就定义好了，保存在方法的code属性中，为max_stack的值
					6.栈中的任何一个元素是可以任意的Java数据类型
						1.32位bit的类型占用一个栈单位深度
						2.62位bit的类型占用两个栈单位深度
					7.操作数栈并非采用访问索引的方式来进行数据访问，而是通过标准的入栈、出栈操作来访问
				栈顶缓存技术
					将栈顶元素全部缓存在物理cpu的寄存器，以此降低对内存读/写次数，提升执行引擎的执行效率
				
				动态链接：
					概念：
						每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用
						在字节码文件中，所有的变量和方法引用都作为符号引用保存在class文件的常量池
					目的：
						为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令
					作用：	
						为了将这些符号引用转换为调用方法的直接引用
					方法绑定机制：
						1.静态绑定（早期绑定）
							如果被调用的目标方法在编译器可知，且运行期保持不变
						2.动态绑定（晚期绑定）
							如果被调用的方法在编译器无法被确定下来，只能在程序运行期将调用方法引用
							转换为直接引用
					方法的调用：
						1.虚方法
							如果被调用的目标方法在编译器可知，且运行期保持不变
							例子：
								静态方法、私有方法、final方法、实例构造器、父类方法
						2.非虚方法
							例子：
								除去以上非虚方法，其余都是
						3.指令	
							1.普通调用指令：
								1.invokestatic：调用静态方法
								2.invokespecial：调用<init>方法
								3.invokevirtual：调用所有虚方法
								4.invokeinterface：调用接口方法
							2.动态调用指令
								5.invokedynamic：动态解析出需要调用的方法，然后执行
								前四条固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic
								指令支持由用户确定方法版本，其中invokestatic + invokespecial指令调用的
								方法称为非虚方法，其余的（final修饰的除外）称为虚方法
							3.方法重写的本质
								在操作数栈顶第一个元素的对象的实际操作类型，然后在常量池找到相符的
								方法，如果找不到则返回java.lang.IllegalAccessError异常，然后接着向上
								找，如果最后找不到则抛出java.lang.AbstractMethodError
							4.虚方法表
								1.jvm采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）
								来实现，使用索引来代替查找
								2.每个类中都有一个虚方法表，表中存放着各个方法的实际入口
								3.虚方法表会在类加载的链接阶段创建并开始初始化，类的变量初始值准备完成后
									Jvm会把该类的方法表也初始化完
				方法返回地址（return address）：
					1.存放调用该方法的pc寄存器的值（即下一条指令的值）
					2.一个方法的结束，有两种方式：
						1.正常执行完成
						2.出现未处理的异常，非正常退出
						无论哪种退出，在方法退出后回到该方法被调用的位置。
						1.方法正常退出，调用者的pc计算器的值作为返回地址（该方法的指令的下一条指令地址）
							返回类型：ireturn、return
						2.异常退出的，返回地址是要通过异常表来确定，栈帧一般不会保存这部分信息
				一些附加信息：
					可选
		本地方法栈
			本地方法接口：
				定义：
					一个native method就是一个Java调用非Java代码的接口
					使用native关键字修饰的方法作为本地方法的标志
				作用：
					1.与Java环境外交互
					2.与操作系统的交互
					3.sun’s Java
			1.Java虚拟机栈是管理Java方法的调用，而本地方法栈用于管理本地方法的调用
			2.是线程私有的
			3.使用C语言实现的
			4.允许被实现成固定或者可动态拓展的内存大小
			5.其他Jvm不一定支持本地方法栈
		堆
			概念：
				1.一个进程对应一个Jvm,一个Jvm有一个方法区 + 一个堆
				  一个线程对应一个虚拟机栈、本地方法栈、pc计数器
				2.Java堆区在Jvm启动的时候就被创建，气空间大小也就确定了
					是Jvm管理的最大一块内存空间
					对内存大小是可以调节的
				3.在物理上不连续，但在虚拟上看做是连续的
				4.所有线程共享Java堆，在这里还可以划分私有的缓冲区（Thread Local Allocation Buffer， TLAB）
				5.几乎所有的对象实例都在堆区分配内存
				6.数组和对象可能永远不会存储在栈（只是对象引用地址值）上
					然后这个引用指向堆区的相应对象/数组位置
				7.在方法结束后，堆中的对象不会被马上移除，仅仅在垃圾收集的时候才会被移除
				8.堆是GC（垃圾回收）执行垃圾回收的重点区域
			细分内存结构：
				现代垃圾收集器大部分基于分代收集器理论设计
				Java8之后堆内存逻辑上分为三部分：新生区、养老区、元空间/永久区（Java7）
				1.新生区又划分Eden空间、survivor空间/from区、survivor1空间/to区
					几乎所有的Java对象都是在Eden区被new出来
					绝大部分Java对象的销毁是在新生代进行
			堆空间大小设置：
				1.-Xms
					设置堆空间（年轻代、老年代）初始内存大小
					-X 是Jvm的运行参数
					ms 是memory start
				2.-Xmx
					设置堆空间（年轻代、老年代）最大内存大小
				3.默认堆空间大小
					初始内存大小：物理电脑内存大小  1/64
					最大内存大小：物理电脑内存大小  1/4
				4.新生代、老年代参数设置
					-XX:NewRatio=2    默认设置两者比例，默认1:2(新生代1：老年代2)
					-XX:SurvivorRatio 默认Eden空间与两个survivor空间比例8:1:1
					-XX:-UseAdapteiveSizePolicy 关闭自适应的内存分配策略
			对象分配过程：
				总结：
					1.针对幸存者s0、s1：复制之后有交换，谁空谁是to
					2.关于垃圾回收：频繁在新生区收集，很少在老年区收集，几乎不再永久区/元空间
			MinorGC、MajorGC、FullGC对比：
				1.部分收集
					1.MinorGC（新生代收集）
						1.主要指Eden区满的时候触发，survivor0和survivor1不会触发
						2.因为Java对象大多数都具备朝生夕灭的特性，所以MinorGc非常频繁
						3.MinorGC会引发STW，暂停其他用户线程，等垃圾回收结束，用户线程才回复运行
					2.MajorGC（老年代收集）
						执行时间比较长，由于相对于新生区的空间大
					3.混合收集（MixedGC）
						收集整个新生代以及部分老年代的垃圾收集
				2.整堆收集（FullGC）
					收集整个Java堆 + 方法区的垃圾收集
			对象分配过程：
				TLAB
					1.在Eden区继续划分，Jvm为每个线程分配了一个私有缓存区域（它包含在Eden空间内）
					2.在多线程同时分配内存时，使用TKAB可以避免一系列安全问题，同时还能提升内存分配的吞吐量
						这种分配又名“快速分配策略”
					3.参数
						-XX:UseTLAB  开启TLAB空间
						-XX:TLABWasteTargetPercent  设置TLAB空间所占用Eden空间百分比大小
					4.一旦TLAB空间分配内存失败，Jvm会尝试使用加锁机制确保数据操作的原子性
						从而直接在Eden空间中分配内存
			栈上分配：
				1.逃逸分析
					一个对象没有逃逸出方法的话，那么久可能被优化在栈上分配（线程（虚拟机栈）上栈帧对应方法）
				2.代码优化
					1.栈上分配
						一个对象没有逃逸出方法的话
					2.同步省略
						1.线程同步的代价是降低并发性和性能
						2.判断同步块使用的锁对象是否只能够被一个线程访问并没有被发布到其他线程
							那么JIT编译器就会消除这部分代码的同步，同步省略又名“锁消除”（运行期才会被消除、编译器还是有相应代码存在）
					3.分离对象或标量替换
						概念：	
							允许将对象打散成标量并分配在栈上
						有的对象部分/全部可以不存储在内存，而是存储在cpu寄存器
						1.标量（scalar）
							一个无法再分解成更小的数据。Java的原始数据类型就是标量
						2.聚合量（Aggregate）
							还能分解的数据。Java中的对象就是聚合量（分解成聚合量/标量）
		方法区/元空间
			1.栈、堆、方法区的交互关系
				栈存放变量、堆存放对象、方法区存放.class字节码文件的对象类型数据
				   动态链接引用指向   指针指向
			2.概念	
				1.独立于堆的的内存（本地系统内存）空间（逻辑上属于堆的一部分）
				2.共享区
				3.Jvm启动时就被创建
				4.空间大小可固定可拓展
				5.空间大小决定了系统可以保存多少个类
				6.关闭Jvm就会释放这个方法区
			3.内存空间大小设置参数
				jdk8及之后
					1.-XX:MetaspaceSize=100m
						window系统下，默认21m
					2.-XX:MaxMetaspaceSize=100m
						window系统下，默认-1（没有限制）
			4.内部结构（字节码文件的结构）
				1.可存放类型信息
				2.运行时常量池：虚拟机环境下的class常量池（常量池：class字节码文件的）
					1.原因
						一个Java源文件经过编译产生的class字节码文件，需要加载的本类 + 
						其他用到的类很多，所以不能一次性的加载到一个字节码文件，不然数据很大
						所以会用到动态链接引用指向运行时常量池会更好
					2.常量池可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、
						方法名、参数类型、字面量等类型
					3.Jvm为每个已加载的类型（类/接口）都维护一个常量池。池中的数据项
						像数组项一样是通过索引访问
					4.字节码的常量池引用是用符合引用，虚拟机的运行时常量池是真实地址
					5.运行时常量池相对于class文件的常量池具有动态性
				3.静态变量
				4.JIT编译器代码缓存
				5.域（Field属性）信息
				6.方法信息
				7.non-final的类变量（static修饰的类变量，随类加载而加载）
				8.全局常量（static final修饰的变量在预准备阶段就给变量初始化赋值，
					非final修饰的变量则在预准备阶段后的init初始化赋值）
			5.垃圾回收	
				主要回收常量池中废弃的常量和不再使用的类型
				1.常量
					字面量 + 符合引用
						1.类个接口的全限定名
						2.字段的名称和描述符
						3.方法的名称和描述符
					条件
						只要常量池中的常量没有被任何地方引用，就可以被回收
				2.类型		
					条件
						1.该类所有的实例都已经都回收，也就是Java对中不存在该类及其任何
							派生子类的实例
						2.加载该类的类加载器已经被回收
						3.该类对应的java.lang.Class对象没有在任何地方被引用，无法再任何地方
							通过反射访问该类的方法
		对象					
			1.对象创建的6个步骤
				1.判断对象对应的类是否加载、链接、初始化
				2.为对象分配内存
					1.如果内存规则
						指针碰撞
					2.如果内存不规则
						虚拟机需要维护一个列表（收集空闲空间）
						再进行空闲列表分配
				3.处理并发安全问题
					1.采用cas失败重试、区域加锁保证更新的原子性
					2.head堆的Eden区域采用的TLAB策略（为每个线程预先分配）
				4.初始化分配到的空间
					所有属性设置默认值，保证对象实例字段再不赋值时可以直接使用
				5.设置对象的对象头
				6.执行init方法进行初始化
					1.属性的默认初始化
					2.显示初始化/代码块初始化
					3.构造器初始化
			2.对象的内存布局
				1.对象头（Header）
					1.运行时元数据
						哈希值（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳
					2.类型指针
						指向类元数据InstanceClass，确定该对象所属的类型
					注：如果是数据，还需记录数据的长度
				2.实例数据（Instance Data）
					说明：它是对象真正存储的有效信息，包括编程代码中定义的各种类型字段（包括从父类继承xialde和本身拥有的字段）
					规则：
						1.相同宽度的字段总量被分配在一起
						2.父类中定义的变量会出现在子类之前
						3.如果CompactFileds参数为true，子类的窄变量可能会插入到父类变量的空隙
				3.对齐填充（Padding）
					不是必须的，也没有含义，仅仅起到占位符的作用
			3.对象访问定位
				1.句柄访问
					head空间分出一块用于存放句柄池（包括到对象实例数据指针、到对象类型数据指针）
				2.直接指针（Hotspot采用）
					直接指向对象实例数据，再到对象类型数据
		直接内存（方法区的本地内存）
			概述：
				1.不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域
				2.是在Java堆外的，直接想系统OS申请的内存空间
				3.来源于NIO（本地Native IO），通过存在堆中的DirectByteBuffer操作Native内存
				通常，访问直接内存的速度会优于Java堆（读写性能高）
					1.出于性能考虑，读写频繁的场合可能会考虑使用直接内存
					2.Java的NIO库允许Java程序使用直接内存，用于数据缓冲区
				4.内存大小设置
					-Xmx20m -XX:MaxDirectMemorySize=10m
	执行引擎						
		1.概述：
			1.Java虚拟机核心组成部分
			2.相对于“物理机”的概念
				物理机：
					直接建立在处理器、缓存、指令集和操作系统层面上
				虚拟机：
					由软件自行实现，不搜狐物理条件制约指令集与执行引擎的结构体系
					能够执行那些不被硬件直接支持的指令集格式
			3.主要任务
				将Jvm装载到虚拟机的字节码文件指令解释/编译为对应平台上的本地机器指令
				（即将高级语言二次编译为机器语言）
			4.Java是半解释半编译语言
			5.字节码
				1.是一种中间状态（中间码）的二进制代码文件，比机器码更抽象，需要编译器转译后才能成为机器码
				2.为了实现特定软件运行和软件环境，与硬件环境无关
				3.目的：为了实现Java程序实现跨平台，避免采样静态编译的方式直接生成本地机器指令
		2.解释器（Interpreter）：
			1.概述：
				当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的
				内容“翻译”为对应平台的本地机器指令执行
			2.分类：	
				1.字节码解释器
					通过纯软件代码模拟字节码执行
				2.模板解释器
					每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码
			3.优缺点
				1.效率低（逐行解释）
				2.响应速度快，而不用等JIT编译器（Just In Time Compiler）全部编译完成再执行
				3.作为JIT编译器（Just In Time Compiler）的后备方案
		3.JIT编译器（Just In Time Compiler）：
			1.概述：
				1.虚拟机将源代码直接编译成和本地机器平台相关的机器语言
				2.前端编译器
					Java源文件编译为class文件				
				3.后端编译器
					字节码文件编译成机器码
			2.热点代码及探测方式
				1.作用：
					区别是否使用解释器还是编译器进行编译
				2.概述：
					根据代码被调用执行的频率而定，JIT编译器对热点代码（需要被编译为本地代码的字节码）
					做出优化			
				3.判断方式
					1.一个被多次调用的方法/一个方法体内部循环次数较多的循环体
					2.热点探测功能
						一个方法/循环体次数的标准
				4.基于计数器的热点探测分类：	
					1.方法调用计数器
						用于统计方法的调用次数
						1.client模式下的阈值是1500次
						2.server模式下的阈值是10000次
						3.可通过参数-XX:CompileThreshold设定
						4.热度衰减
							当超过一定时间限度，如果方法的调用次数任然不足让它提交给JIT编译器
							那么这个方法的调用计数器就会减半（简称衰减Counter Decay），而这段
							时间成为此方法统计的半衰周期（Counter Half Life Time）
						5.-XX:-UseCounterDecay可设置关闭热度衰减
						6.-XX:CounterHalfLifeTime可设置半衰周期时间，单位是秒s
					2.回边计数器
						1.用于统计方法循环体执行的循环次数
						2.回边
							概述：在字节码中遇到控制流向后跳转的指令
							目的：触发OSR编译
								OSR（栈上替换On Stack Replacement）方法在虚拟机栈以栈帧方式存在
			3.分类：
				1.C1（Client）
					指定Java虚拟机运行在Client模式下，并使用C1编译器
					特点：
						对字节码进行简单和可靠的优化、耗时短，以达到更快的编译速度
				2.C2（Server）
					指定Java虚拟机运行在Server模式下，并使用C2编译器
					特点：
						耗时较长的优化，以及激进优化，但优化的代码执行效率更高
				3.C1和C2的不用优化策略
					1.C1的策略
						1.方法内联
							将引用的函数代码编译到引用点处，这样可减少栈帧的生成，减少参数传递以及跳转过程
						2.去虚拟化
							对唯一的实现类进行内联
						3.冗余消除
							在运行期间把一些不会执行的代码折叠掉
					2.C2的策略
						1.标量替换
							用标量值代替聚合对象的属性值
						2.栈上分配
							对于未逃逸的对象分配在栈而不是堆
						3.同步消除
							清除同步操作，通常指synchronized
		4.HotSpot VM设置程序执行方式
			1.-Xint
				完全采用解释器模式执行程序
			2.-Xcomp
				完全采用JIT编译器模式执行程序，如果JIT编译器出现问题，解释器会接入执行
			3.-Xmixed
				采用解释器 + JIT编译器的混合模式共同执行程序
	垃圾回收（GC）
		1.概述：
			1.什么是垃圾？
				在运行程序中没有任何指针指向的对象
			2.为什么需要GC？
				1.内存会被消耗完
				2.Jvm将整理出内存分配给新的对象
				3.不能保证应用程序正常进行
			3.Java垃圾回收机制
				自动内存管理
					优点：无需开发人员手动参与内存的分配和回收，可以降低内存泄露和内存溢出的风险
					缺点：弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力
						  实施必要的监控和调节（JProfiler/Eclipse mnt工具溯源分析GC Roots）
			4.作用：
				主要作用于方法区和堆区
		2.垃圾回收算法
			1.标记阶段
				1.引用计算算法
					1.概述：
						对每个对象保存一个整型的引用计数器属性，用于记录对象被引用情况
						即：对于一个对象A，只要任何一个对象引用了A，则A的引用计数器就加1，
							当引用失效，引用计数器就减1，只要对象A的引用计算器为0，则对象A
							就不再被使用，可进行回收
					2.优缺点
						优点：实现简单，垃圾对象便于辨识，判定效率高，回收没有延迟性
						缺点：
							1.因其需要单独的字段存储计数器，所以增加了存储空间的开销
							2.伴随着加减法，增加了时间开销
							3.无法处理循环引用的情况而导致内存泄露，所以Java没有使用这类算法
				2.可达性分析算法（根搜索算法/追踪性垃圾收集）
					相对于引用计数算法，其同样具备实现简单和执行高效等特点，更重要的是该算法有效的解决
					在引用计数算法中循环引用的问题，防止内存泄露的发生
					1.概述：
						“GC Roots”根集合就是一组必须活跃（存活）的引用
						基本思路：
							1.以根对象集合（GC Roots）为起始点，按照从上到下的方式搜索被根对象集合所
							  连接的目标对象是否可达
							2.使用可达性分析算法后，内存中的存活对象会被根对象集合直接/间接连接着
							  搜索所走过的路径称为“引用链”
							3.如果目标对象没有被任何引用链相连，则是不可达的，可被标记为垃圾对象
							4.能够被根对象直接/间接连接的对象才是存活对象
						判断可以作为GC Roots的以下几类元素
							1.虚拟机栈中引用的对象
							2.本地方法栈内JNI（通常说的本地方法）引用的对象
							3.方法区中类静态属性引用的对象
							4.方法区中常量引用的对象
							5.分代收集和局部回收
								比如：堆空间的新生代的（Eden、s1、s2）里面的引用
							识别小技巧
								由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的
								对象，但自己又不存放在堆内存里面，那它就是一个Root
						注意点：
							分析工作必须在一个能保障一致性的快照中进行（即一个固定时间点的对象状态）
							缺点：导致GC进行时必须“Stop The World”（停顿）
			2.对象的finalization机制（对象终止）
				1.对象被销毁之前的自定义处理逻辑
				2.当垃圾回收器发现没有引用指向一个对象，即：垃圾回收对象之前，总会先调用
				  这个对象的finalize（）方法（存于Object超类的方法）
				3.finalize（）方法允许在子类中被重写，用于在对象被回收时进行资源释放
				4.永远不要主动的调用某个对象的finalize（）方法
					原因：
						1.可能导致对象复活
						2.执行时间没有保障，它完全由GC线程决定，极端情况下，若不发生GC，则finalize（）方法将没有机会执行
						3.一个糟糕的finalize（）方法会影响GC性能
				5.虚拟机中对象一般处于三种可能的状态
					1.可触及的
						从根节点开始，可达的这个对象
					2.可复活的
						对象的所有引用被释放，但对象可能在finalize（）方法仲复活
					3.不可触及的
						对象的finalize（）方法被调用，并没有复活（finalize（）方法只能被调用一次）
				6.判断一个对象是否可回收，至少经历两次标记过程
					1.如果对象objA到GC Roots没有引用链，则进行第一次标记
					2.进行筛选，判断此对象是否有必要执行finalize（）方法
						1.如果没有重写finalize（）方法/finalize（）方法已经被虚拟机调用过
						  则虚拟机视为“没必要执行”，objA被判定为不可触及
						2.如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被
						  插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发finalize（）方法
						3.finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记
							1.如果objA在finalize（）方法于引用链上的任何一个对象建立了联系，那么在第二次标记时，
							  objA会被移出“即将回收”集合。
			3.清除阶段
				1.标记-清除算法（Mark-Sweep）
					执行过程：
						1.标记
							标记可达对象
						2.清除
							回收垃圾对象
					优缺点：
						缺点：效率不算高、需停止整个应用程序才能回收、清理出来的空闲区不连续（需要维护空闲列表）
						
				2.复制算法（Copying）
					概述：
						将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存
						中的存活对象复制到未使用的内存块中，之后清除正在使用的内存块中的所有对象，
						交换两个内存的角色，最后完成垃圾回收
					优缺点：
						优点：
							高效率、保证空间的连续性
						缺点：
							需要两倍的内存空间、内存占用/时间开销不小（维护指针引用，因为复制对象，地址改变了）
							应用的区域不用过大
				3.标记-压缩（整理）算法（Mark-Compact）
					执行过程：
						标记
							从根节点开始标记所有被引用的对象
						压缩
							将所有的存活对象压缩到内存的一段，按顺序排放
							之后，清理边界外所有的空间
					优缺点
						相对于标记-清除算法（一种非移动式回收算法：没有进行内存碎片整理，需要维护内空闲列表），
						标记-压缩算法（移动式：有进行内存碎片整理），但是指针（地址）改变了，
						其引用也要改变
						缺点：
							效率低于复制算法、移动对象时也要调整引用的地址、移动过程需要停顿应用程序（STW）
				4.分代收集算法
					讲述关于堆空间的新生代和老年代使用哪种算法能达到效率更高，而不是一种算法
				5.增量收集算法（降低系统停顿时间）
					背景：
						在垃圾回收过程中，应用程序所有线程都会被挂起
					基本思想：
						垃圾收集线程和应用程序线程交替执行（垃圾收集线程只收集一小片区域的内存空间
						接着切换到应用程序线程，一次反复，直到垃圾收集完成）
					作用：
						对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清除、复制工作
					缺点：
						因为线程切换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降
				6.分区算法（降低系统停顿时间）
					概述：
						按照对象的生命周期长短划分为两部部分，将整个堆空间划分为连续的不同的小区间region
						每个小区间都独立使用，独立回收
					优点：
						可以控制一次回收多少个小区间
		3.垃圾回收相关概念
			1.System.gc（）的理解
				1.触发Full GC（新生代、老年代进行回收）
				2.附带免责声明，无法保证对垃圾收集器的调用
				3.一般都是自动进行的
				4.等同于Runtime.GetRuntime（）.gc（）
				5.System.runFinalization（）表示强制调用引用对象的finalize（）方法
			2.内存溢出和内存泄露
				1.内存溢出（OOM）
					原因：
						1.Java虚拟机堆空间内存设置不够
						2.代码中创建了大量大对象，并且长时间不能被垃圾收集器回收
				2.内存泄露（Memory Leak）
					概述：
						只有对象不再被程序用到，但GC又回收不了的情况，有可能导致OOM
					举例：
						1.单例模式
						2.一些提供close的资源未关闭（dataSource、socket）
			3.Stop The World（STW：停顿）
				概述：
					指的是GC事件发生过程中，会产生应用程序的停顿
				举例：
					可达性分析算法会导致停顿
					原因：
						1.确保一致性的快照中进行
						2.分析期间，整个系统看起来像被冻结在某个时间点上
						3.如果分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证
				注意：
					1.STW事件与采用哪款GC无关，所有的GC都有这个事件
					2.只有回收效率越来越高，尽可能缩短了暂停时间
					3.是Jvm在后台自动发起和自动完成的，在用户不可见的情况下，把用户正常的工作线程全部停掉
					4.System.gc（）会导致STW发生
			4.垃圾回收的并行与并发
				1.应用程序层面上
					1.并发（Concurrent）
					概述：
						1.在操作系统中，是指在一个时间段中有几个程序都处于启动运行到运行完毕之间，
						  且这几个程序都是在同一个处理器上运行
						2.并发并不是真正意义上的“同时进行”，只是cpu把同一个时间段分为几个时间片段（时间区间）
						  然后在这几个时间区间之间来回切换，由于cpu处理速度非常快，只要时间间隔处理得当，即可
						  让用户感觉是多个应用程序同时在运行
					2.并行（Parallel）
						概述：
							当系统有一个以上cpu时，当一个cpu执行一个进程时，另一个cpu可以执行另一个进程，两个
							进程互不抢占资源，可以同时进行
							注意：
								决定并行的因素不是cpu的数量，而是cpu的核心数量。比如一个cpu多个核也可以并行
					3.两者对比
						1.并发，指的是多个事情在同一个时间段内同时发生
						  并行，指的是多个事情在同一个时间点上同时发生
						2.并发的多个任务之间是互相抢占资源的
						  并行的多个任务之间是不互相抢占资源的
						3.只有在多cpu/一个cpu多核情况下，才会发生并行
						  否则看似同时发生的事情，其实都是并发执行的
				2.垃圾回收层面上
					1.并行（Parallel）
						概述：
							指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态
					2.串行（Serial）
						概述：
							1.相对于并行的概念，单线程执行
							2.如果内存不够，则程序暂停，启动Jvm垃圾回收期进行回收。
							  回收完，再启动程序的线程
					3.并发（Concurrent）
						概述：
							指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）
							垃圾回收线程在执行时不会停顿用户程序的运行
						举例：
							用户程序在继续运行，而垃圾收集程序线程运行在另一个cpu上
			5.安全点与安全区域
				1.安全点（Safe Point）
					1.概述：
						程序执行时并非所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来
						开始GC，即安全点
					2.安全点选择依据
						判断是否具有让程序长时间执行的特征为标准（可乘着长时间进行停顿GC）
						比如：方法调用、循环跳转、异常跳转
					3.检查所有线程如何跑到最近安全点停顿
						1.抢先式中断（目前没有虚拟机采用）
							首先中断所有线程，如果还有线程不在安全点，则会吸附线程让其跑到安全点
						2.主动式中断
							设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志
							如果中断标志为true，则将自己进行中断挂起
				2.安全区域（Safe Region）
					1.概述：
						指的是在一段代码片段中，对象的引用关系不会发生变化，在这个区域中任何位置开始GC都是安全的
						可以看做是安全的的拓展
					2.实际执行时
						1.当线程运行到安全区域的代码时，首先标志已经进入到安全区域
						  如果这段时间内发生GC，Jvm会忽略安全区域状态的线程
						2.当线程离开安全区域时，会检查Jvm是否已经完成GC，如果完成了，
						  则继续运行，否则线程必须等待直到收到可以安全离开安全区域的信号
			6.引用
				1.强引用（Strong Reference）--不回收且默认引用
					概述：
						指程序代码中普遍存在的引用赋值（例：Object obj = new Object（））
						无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收被引用的对象
					缺点：
						OOM异常主要来源
					特点：
						1.强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象
						2.只要引用的作用域设置为null，则当做是被垃圾收集
						3.相对的，软引用、弱引用、虚引用的对象是软可触及、弱可触及、虚可触及
				2.软引用（Soft Reference）--内存不足即回收
					概述：
						在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收，
						如果第二次回收后还没有足够的内存，才会抛出OOM异常
					作用：
						1.描述一些还有用但非必需的对象
						2.通常用来实现内存敏感的缓存（比如：高速缓存就有软引用，迫不得已才清理）
					方式：
						SoftReference<对象类型User> sf = new SoftReference<对象类型User>（强引用对象obj）
					注意：
						被回收时，会把对象放入队列，等待回收
				3.弱引用（Weak Reference）--发现即回收
					概述：
						被弱引用关联的对象只能生存到下一次垃圾收集之前
						当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象
					作用：
						1.描述一些还有用但非必需的对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止
						  其生命周期是取决于垃圾回收器不一定很快执行，其在这种情况下可以较长时间存在
						2.通常用来实现可有可无的数据的缓存（比如：高速缓存就有软引用，迫不得已才清理）
					方式：
						WeakReference<对象类型User> sf = new WeakReference<对象类型User>（强引用对象obj）
					注意：
						被回收时，会把对象放入队列，等待回收
				4.虚引用/幽灵引用/幻影引用（Phantom Reference）--对象回收跟踪
					概述：
						一个对象是否有虚引用存在，虚引用的存在完全不会对其生存时间构成影响，也无法
						通过虚引用来获得一个对象的实例
					目的：
						能在对象被收集器回收时收到一个系统的通知
					特点：
						存亡与对象生命周期无关、不能获取对象
					注意：
						被回收时，会把对象放入队列，等待回收
					方式：
						ReferenceQueue pq = new ReferenceQueue（）；
						PhantomReference<对象类型User> sf = new PhantomReference<对象类型User>（强引用对象obj， pq）；
					作用：
						由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录（Queue队列里面的对象）
				5.终结器引用/终结器引用（Final Reference）
					概述：
						1.用以实现对象的finalize（）方法
						2.无需手动代码，其内部配合引用队列使用
						3.在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用
						  对象并调用它的finalize（）方法，第二次GC时才能回收被引用对象
	垃圾回收器
		1.分类与性能指标
			1.分类
				1.按线程数分
					1.串行垃圾回收器
					2.并行垃圾回收器
				2.按工作模式分
					1.并发垃圾回收器
					2.独占式垃圾回收器
				3.按碎片处理方式分
					1.压缩式垃圾回收器
						指针碰撞
					2.非压缩式垃圾回收器
						空闲列表
				4.按工作的内存区间分
					1.年轻代垃圾回收器
					2.老年代垃圾回收器
			2.性能指标
				1.吞吐量（throughput要点）
					运行用户代码的时间占总运行时间（程序运行时间 + 内存回收时间）的比例
					注意：	
						应用程序线程开跑
				2.垃圾收集开销
					吞吐量的补数，垃圾收集所用时间与总运行时间的比例
				3.暂停时间/低延迟（pause time要点）
					执行垃圾收集时，程序的工作线程被暂停的时间
					注意：	
						应用程序线程暂停
				4.收集频率
					相对应用程序的执行，收集操作发生的频率
				5.内存占用
					Java堆区所占的内存大小
				6.快速
					一个对象从诞生到被回收所经历的时间
				对比（吞吐量 vs 暂停时间/低延迟）
					1.高吞吐量可以给用户感觉到应用程序在做“生产线”工作
					2.低延迟较好因为最终用户角度来看不管是GC还是其他原因导致一个应用程序被挂起始终是不好的
					  有时候甚至短暂的200ms暂停都可能打断终端用户体验
					3.两者是一对相互竞争的目标（矛盾）
						原因：
							1.如果吞吐量优先，那么必然需要降低内存回收的执行效率，这样会导致GC需要更长的
							  暂停时间来执行内存回收
							2.如果低延迟优先，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收
							  但这又导致年轻代内存的缩减和程序吞吐量下降
					4.一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量/最小暂停时间），或
					  尝试找到一个两者的折裹
					5.现在标准
						在最大吞吐量优先下，降低停顿时间
		2.不同垃圾回收器
			发展史
				1.串行回收器
					Serial、Serial Old
				2.并行回收器
					ParNew、Parallel Scavenger、Parallel Old
				3.并发回收器
					CMS、G1（新生代和老年代共同垃圾回收）
			作用：
				选择对具体应用最合适的垃圾回收器
			参数：
				1.-XX:+PrintCommandLineFlages（查看命令行相关参数，包括使用的垃圾回收器）
				2.命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID（通过jps查看）
		3.Serial回收器：串行回收
			1.Jdk1.3之前新生代唯一选择、采用复制算法、串行回收、STW机制方式执行内存回收
			2.配合Serial Old回收老年代使用
			3.优点：
				简单高效、开销低、单线程效率高（也是单核处理的缺点）
			4.参数：
				-XX:+UseSerialGC配置指定新生代Serial和老年代Serial Old垃圾回收器
		4.ParNew回收器：并行回收
			1.只能处理新生代、多线程并行方式高效
			2.老年代使用串行垃圾回收器（老年代回收频率低以节省资源）
			3.参数：
				-XX:ParallelGCThreads限制线程数量，默认开启cpu相同线程数
		5.Parallel Scavenge回收器：吞吐量优先
			1.采用复制算法、并行回收、STW机制方式执行内存回收
			2.主要适合在后台运算而不需要太多交互的任务，常见在服务器环境中使用
			3.老年代使用Parallel Old回收器
			4.Jdk8默认此垃圾回收器
			5.参数：
				1.-XX:+UseParallelGC手动指定年轻代使用Parallel并行回收器执行内存回收任务
				2.-XX:+UseParallelOldGC手动指定老年代使用并行回收器执行内存回收任务
					1.Jdk8默认此垃圾回收器
					2.上面两个参数，默认开启一个，另一个也会被开启（互相激活）
				3.-XX:ParallelGCThreads设置年轻代并行回收器的线程数
				  一般的，最好与cpu数量相等，以避免过多的线程数影响垃圾回收性能
					1.默认情况下，当cpu数量小于8个，ParallelGCThreads值等于cpu数量
					2.当cpu数量大于8个，ParallelGCThreads值等于3 + [5 * cpu_count]/8
				4.-XX:MaxGCPauseMillis设置垃圾回收器最大停顿时间（STW时间，单位ms）
					1.为了尽可能地把时间控制在MaxGCPauseMillis以内，回收器在工作时会调整Java堆大小/其他一些参数
					2.对于用户来讲，停顿时间越短体验越好，但是在服务器断，我们注重高并发，整体的吞吐量，所以服务器端
					  适合Parallel进行控制
					3.该参数使用需谨慎
				5.-XX:GCTimeRatio垃圾回收器收集时间占总时间的比例（= 1 / （N + 1））
					用于衡量吞吐量大小
					1.取值范围（0,100），默认值99，也就是垃圾回收时间不超过1%
					2.与前一个-XX:MaxGCPauseMillis参数有一定矛盾，暂停时间越长，Ratio参数就容易超过设定的比例
				6.-XX:+UserAdaptiveSizePolicy设置Parallel Scavenge回收器具有自适应调节策略
					1.在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代
					  的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点
					2.在手动调优比较困难的场合，可以直接使用这种自适应方式，仅指定虚拟机的最大堆、目标吞吐量（GCTimeRatio）
					  和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作
		6.CMS回收器（ConCurrent-Mark-Sweep）：低延迟
			1.强交互应用
			2.真正意义上的并发回收器，第一次实现了让垃圾回收线程和用户线程同时工作
			3.主要关注垃圾收集时，用户线程的停顿时间
			4.采用标记-清除算法，并且也会STW效应
			5.工作原理：
				1.初始标记（Initial-Mark）
					1.所有工作线程都会因为STW机制出现停顿
					2.主要任务
						仅仅标记出GC Roots能直接关联到的对象
					3.恢复被暂停的应用线程
					4.速度比较快
				2.并发标记（ConCurrent-Mark）
					从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程比较长但不需要停顿
					可以和垃圾回收线程一起并发运行
				3.重新标记（Remark）
					由于并发阶段，程序的工作线程和垃圾回收线程同时运行/交叉运行，因此，为了修正
					并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，
					这个阶段的停顿时间通常会比初始标记稍长一些，但远比并发标记时间短
				4.并发清除（ConCurrent-Sweep）
					清理删除标记阶段判断的已经死亡的对象，释放内存空间，且用户线程和垃圾回收线程同时并发
			6.特点：
				1.STW暂停时间
				2.整体回收时低停顿的（用户线程和垃圾回收线程并发进行）
				3.确保用户线程有足够内存可用
				4.当堆内存使用率达到一定阈值，会发生GC
				5.采用的标记-清除算法，所以会产生内存碎片，需要使用空闲列表
				6.无法处理浮动垃圾
					在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记
					最终会导致这些新产生的垃圾对象没被及时回收（因为用户线程是并发运行的）
			7.参数：
				1.-XX:+UseConcMarkSweepGC手动指定CMS回收器执行内存回收任务
					1.开启后默认开启-XX:UseParNewGC，即：ParNew(Young区用) + CMS（old区用）+ Serial Old的组合
				2.-XX:CMSlinitiatingOccupanyFraction设置堆内存使用率的阈值，一旦达到该值，则开始GC
					1.Jdk8及之后5之前默认值68，即当老年代的空间使用率达到68%就开始一次GC
					  Jdk6以上默认值92
					2.如果内存缓慢增长，则设置大的值，可以有效降低CMS触发频率
					  反之，如果内存使用率增长很快，则降低这个值，以免频繁触发老年代串行回收器
					  因此，这个参数设置可以有效降低Full GC的执行次数
				3.-XX:+UseCMSCompactAtFullCollection用于指定执行完Full GC后对内存空间进行压缩
					整理，以此避免内存碎片的产生，不过由于内存压缩整理过程无法并发执行，所带来的
					问题就是停顿时间变得更长
				4.-XX:CMSFullGCBeforeCompaction设置在执行多少次Full GC后对内存空间进行压缩整理
				5.-XX:ParallelCMSThreads设置CMS的垃圾回收线程数量
					1.CMS默认启动的线程数是：（ParallelGCThreads + 3） /4
					2.ParallelGCThreads是年轻代并行回收器的线程数，当cpu资源比较紧张时，受到CMS
					  回收器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕
			8.小结
				口令：
					1.如果你想要最小化地使用内存和并行开销，请选Serial GC
					2.如果你想要最大应用程序的吞吐量，请选Parallel GC
					3.如果你想要最小化的中断/停顿时间，请选CMS GC
		7.G1回收器：区域划分代式
			1.目标
				在延迟可控的情况下，获得尽可能的高的吞吐量
			2.概述：
				1.是一个并行回收器，把堆内存分割成很多不相干的区域（Region）
				  使用不同的区域来表示Eden、S0、S1、老年代等
				2.有计划地避免整个Java堆中进行区域的垃圾收集。G1跟踪各个区域里面的垃圾堆积
				  的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个
				  优先列表，每次根据允许的收集时间，优先回收价值最大的区域
				3.其侧重点在于回收垃圾最大量的区间，所以又名：垃圾优先（Garbage First）
				4.面向服务器端的垃圾回收器，主要针对配备多核cpu及大容量的机器，以极高概率满足GC
				  停顿时间的同时，还兼具高吞吐量的性能特征
				5.Jdk9以后默认垃圾回收器，取代CMS回收器以及Parallel + parallel Old组合
				6.全功能的垃圾回收器
			3.优点：
				1.并行与并发
					1.并行性
						多个GC线程同时工作，有效利用多核计算能力，此时用户线程STW较长
					2.并发性
						用户线程与回收线程交替执行，部分工作两者可以同时执行
						因此不会出现整个回收阶段发生完全阻塞应用程序的情况
				2.分代收集
					1.从分代看，G1属于分代型垃圾回收器
					  从堆结构看，它不要求整个Enen区、年轻代、老年代，也不再坚持固定大小喝数量
					2.将堆空间分为若干个区域，这个区域在逻辑上包含年轻代和老年代
					3.兼顾年轻代和老年代垃圾回收
				3.空间整合
					1.其内存回收以region作为基本单位
					  区域Region采用复制算法，整体上看作是标记-压缩算法，两种算法都可以
					  避免内存碎片
				4.可以预测的停顿时间模型（即：软实时soft real time）
					1.建立可预测的停顿时间模型，明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾回收
					  的时间不能超过N毫秒（即：吞吐量（M - N）/ M）
					2.因为分区，所以只选取部分区域进行内存回收，这样缩小了回收范围，因此
					  对于全局停顿情况的发生也能得到较好的控制
					3.G1跟踪各个区域里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值）
					  在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的区域，保证G1回收器在有限
					  的时间内可以获取尽可能高的回收效率
					4.相对于CMS，G1未必能做到CMS在最好的情况下的延迟停顿，但最差情况要好很多
					5.缺点：
						占内存比CMS要高
						小内存使用CMS，大内存使用G1
			4.参数
				-XX:+UseG1GC
					手动指定使用G1执行内存回收任务
				-XX:G1HeapRegionSize
					设置每个区域的大小，值是2的幂，范围是1M-32M之间，目标是根据最小的
					Java堆大小划分出约2048个区域，默认堆内存是1/2000
				-XX:MaxGCPauseMillis
					设置期望达到最大GC停顿时间指标（Jvm会尽力实现，但不保证达到），默认值200ms
				-XX:ParallelGCThread
					设置STW工作线程数的值，最多设置8
				-XX:ConGCThreads
					设置并发标记的线程数，将n设置为并行垃圾回收线程数（ParallelGCThread）的1/4左右
				-XX:InitiatingHeapOccupancyPercent
					设置触发并发GC周期的Java堆占用率阈值，超过此值就触发GC，默认值是45
			5.使用场景
				1.面向服务器端应用，针对具有大内存、多处理器的机器
				2.需要低GC延迟、具有大堆内存应用
			6.分区Region
				1.将整个堆空间划分约为2048个大小相同的独立的不连续的region区，每个区域块大小
				  根据堆空间的实际大小而定，整体被控制在1M-32M之间，且为2的N次幂，即
				  1M，2M，4M，8M。
				  可以通过-XX:G1HeapRegionSize参数设置，所有的区域大小相同，且Jvm生命周期
				  内不会被改变
				2.虽然还保留着新生代和老年代，但不再是物理隔离了，他们都是一部分区域的集合
				  通过区域的动态分配方式实现逻辑上的连续
				3.一个区域region有可能属于Eden、S1、S0、老年代的内存区域，但一个区域只可能属于
				  其中一个角色（这个角色会在回收再分配后而改变）
				4.Humongous内存区域，主要用于存储大对象
				  如果超过1.5个region，则放入Humongous
					原因：
						1.默认分配到老年代，但对于短期存在的大对象就会对垃圾回收造成负面影响
						2.可用连续的H区来存储一个H区存放不下的大对象
						3.G1大多数行为把H区看作是老年代的一部分
			7.回收过程
				1.年轻代（Young GC）
					1.当Eden区用尽时，开始年轻代回收，这个过程是一个并行的独占式的回收，
					  这个过程中，会暂停所有应用程序线程，启动多线程执行年轻代回收，然后
					  从年轻代区移动存活对象到Survivor区间/老年代区间/两种都涉及
					2.Eden区主动触发回收，S0和S1属于被动回收
					3.具体回收过程
						1.扫描根
							正在执行的方法调用链条上的局部变量等，连同Remember Set
						2.更新Remember Set
							处理dirty card queue中的card，更新Remember Set，此阶段完成后，
							可准确反映老年代对所在的内存分段中对象的引用
						3.处理Remember Set
							识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象
						4.复制对象
							Eden区内存中存活的对象会被复制到Survivor区中的空内存分段，如果Survivor区内存
							中存活的对象年龄未达到阈值，年龄+1，达到阈值则复制到Old区，如果Survivor区空间不够，Eden
							空间的部分数据会直接晋升到老年代空间
						5.处理引用
							处理Soft、Weak、Phantom、Final、Jni Weak等引用
				2.老年代并发标记（ConCurrent Marking）
					当堆空间使用达到一定值（默认45%）时，开始执行这个过程
					1.具体回收过程
						1.初始标记阶段
							标记根节点可达的对象，这个阶段是STW的，并且会触发一次年轻代GC
						2.根区域扫描（Root Region Scanning）
							扫描Survivor区直接可达的老年代区域对象，必须在Young GC之前完成（因为Young GC会触发Survivor区GC）
						3.并发标记（Concurrent Marking）
							在整个堆中进行并发标记
						4.再标记（Remark）
							由于应用程序持续进行，需要修正上一次的标记结果
						5.独自清理（cleanup，STW）
							计算各个区域的存活对象和GC回收比例，并进行排序识别可混合回收的区域
							这个阶段并不会实际去做垃圾回收
						6.并发清理阶段
							识别并清理完全空闲的区域
				3.混合回收（Mixed GC）
					1.老年代标记完成立马执行，
					2.不需要整个回收老年代，一次只需要扫描/回收一小部分老年代区域就可以
					3.老年代和年轻代一起被回收的过程
					4.具体回收过程
						1.并发标记完成后，老年代百分比为垃圾的被回收，部分为垃圾的内存被计算出来
						  ，默认情况下，这些老年代内存分段为8次（可用-XX:GCMixedGCCountTarget设置）
						  被回收
						2.回收包括1/8的老年代内存分段、Eden区内存、Survivor区内存分段
						3.在老年代8次回收中，G1会优先回收垃圾多的内存分段，并且有一个阈值决定内存分段
						  是否被回收（-XX:G1MixedGCLiveThresholdPercent，默认65%）
						4.混合回收不一定要进行8次，有一个阈值（-XX:G1HeapWastePercent，默认10%），意思是
						  运行整个堆内存中有10%的空间被浪费，意味着，如果发现可以回收的垃圾堆内存比例低于10%，
						  则不再进行混合回收
				顺时针顺序：Young GC--ConCurrent Marking--Mixed GC
				4.Full GC（可选）
					触发情况：
						1.Evacuation的时候没有足够的to-space来存晋升的对象
						2.并发处理过程完成之前空间被耗尽
				5.记忆集（Remember Set）
					作用：记忆这个区域的对象引用（Reference）记录，而不用全局扫描堆空间垃圾情况
						1.避免全局扫描
						2.每个区域Region都有一个对应的Remember Set
						3.每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作
						  然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region
							1.如果不同，通过CardTable把相关引用信息记录到引用指向对象所在Region对应的
							  Remember Set中
						  当垃圾回收时，在GC根节点的枚举范围加入Remember Set就可以抱着不进行全局扫描也不会有遗漏  
		8.GC日志分析
			1.参数：
				-XX:+PrintGC（-verbose:gc等同）
				-XX:+PrintGCDetails输出详细日志
				-XX:PrintGCTimeStamps输出GC的时间戳（以基准时间的形式）
				-XX:+PrintGCDateStamps输出GC的时间戳（以日期的形式）
				-XX:+PrintHeapAtGC在进行GC的前后打印出堆的信息
				-Xloggc:../logs/gc.log日志文件的输出路径
			2.日志数据分析
			3.日志分析工具
				例如：
					GCViewer、GCEasy、GCHisto、GCLogViewer
		9.垃圾回收器新发展
			1.Shenandon GC
				1.Open Jdk
				2.RedHat研发
				3.旨在针对Jvm的内存回收实现低停顿的需求
			2.ZGC
				1.Oracle Jdk
				2.Jdk14之前，ZGC仅Linux才支持
				3.在尽可能对吞吐量影响不大的前提下，实现在任意内存大小下都可以把垃圾
				  回收的停顿时间限制在10ms之内的低延迟
				4.使用读屏障、染色指针、内存多重映射等技术实现可并发的标记-压缩算法
				  以低延迟为首要目标的一款垃圾回收器
				5.工作过程的四个阶段
					并发标记--并发预备重分配--并发重分配--并发重映射
				6.在Mac/Windows上使用ZGC，使用如下参数
					-XX:+UnlockExperimentalVMOptions -XX:+UseZGC
	 
	 
	 
	


	 
	 
	 
	 
	 
	 
	 
	