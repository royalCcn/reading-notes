解决端口冲突：
1.查找被占用端口命令
	netstat -ano  或者  netstat -aon|findstr "8181"
2.然后记下最后一位数字，即PID    10368
3.继续输入tasklist|findstr "10368"，回车，查看是哪个进程或者程序占用了10368端口
4.taskkill /f /t /im Tencentdl.exe结束相关进程


yk的订单的流水同步到dms
yk订单确认之后还能修改流水（确认同步之后dms是有数据了）
流水不用删除了、只有新增、编辑

 
 
/**
     * yk流水同步到dms的dms_order_payment表
     *
     * @param orderVo
     */
    private void insertDmsOrderPayment(YkTrackOrderVo orderVo) {
        List<DmsOrderPaymentVo> list = ykTrackOrderMapper.findCashierAndOrder(orderVo.getId());
        String code = ykTrackOrderMapper.findCodeByOrderId(orderVo.getId());
        Integer orderId = ykTrackOrderMapper.findDmsOrderById(code);
        if (ykTrackOrderMapper.findDmsCode(code) == 0) {
            for (DmsOrderPaymentVo dmsOrderPaymentVo : list) {
                if (BlankUtil.isNotEmpty(dmsOrderPaymentVo.getStatus()) && 0 == dmsOrderPaymentVo.getStatus()) {
                    dmsOrderPaymentVo.setCashierAmount(BigDecimal.ZERO);
                }
                dmsOrderPaymentVo.setOrderId(orderId);
                ykTrackOrderMapper.insertDmsOrderPayMent(dmsOrderPaymentVo);
            }
        }
    }
	
	
	
	//同步更新已有的产品到dms
	if (BlankUtil.isNotEmpty(param.getOrderStatus()) && 5 == param.getOrderStatus()) {
		DmsOrderProduct dmsOrderProduct = ykTrackOrderMapper.findDmsOrderProductById(orderProduct.getDmsId());
		dmsOrderProduct.setCount(orderProduct.getCount());
		dmsOrderProduct.setRealPrice(orderProduct.getRealPrice());
		dmsOrderProduct.setPreferentialAmount(orderProduct.getPreferentialAmount());
		dmsOrderProduct.setProductsPrice(orderProduct.getProductsPrice());
		dmsOrderProduct.setOriginalPrice(orderProduct.getPrice());
		dmsOrderProduct.setPrice(orderProduct.getPrice());
		dmsOrderProduct.setCount(orderProduct.getCount());
		dmsOrderProduct.setLastUpdatedBy(param.getCreatedBy());
		dmsOrderProduct.setLastUpdatedDate(new Date());
		dmsOrderProduct.setId(orderProduct.getDmsId());
		dmsOrderProduct.setLastUpdatedDate(new Date());
		dmsOrderProduct.setLastUpdatedBy(param.getCreatedBy());
		ykTrackOrderProductMapper.updateDmsOrderProduct(dmsOrderProduct);

	}
		

//同步新增订单产品到dms
	if (BlankUtil.isNotEmpty(param.getOrderStatus()) && 5 == param.getOrderStatus()) {
		DmsOrderProduct dmsOrderProduct = new DmsOrderProduct();
		dmsOrderProduct.setCount(orderProduct.getCount());
		dmsOrderProduct.setOrderId(param.getDmsId());
		dmsOrderProduct.setGoodsId(orderProduct.getGoodsId());
		dmsOrderProduct.setIsPresent(orderProduct.getIsPresent());
		dmsOrderProduct.setProductSpec(orderProduct.getProductSpec());
		dmsOrderProduct.setRealPrice(orderProduct.getRealPrice());
		dmsOrderProduct.setProductName(orderProduct.getProductName());
		dmsOrderProduct.setPreferentialAmount(orderProduct.getPreferentialAmount());
		dmsOrderProduct.setProductsPrice(orderProduct.getProductsPrice());
		Map<String, Object> map = new HashMap<>();
		map.put("productId", orderProduct.getProductId());
		map.put("dealerId", param.getDealerId());
		Map<String, Object> productSpec = ykTrackOrderMapper.getDmsProductByProductId(map);
		dmsOrderProduct.setProductId((Long) productSpec.get("product_id"));

		if (productSpec.containsKey("name")) {
			dmsOrderProduct.setUnit((String) productSpec.get("name"));
		} else {
			dmsOrderProduct.setUnit(orderProduct.getProductSpec());
		}

		dmsOrderProduct.setOriginalPrice(orderProduct.getPrice());
		dmsOrderProduct.setPrice(orderProduct.getPrice());
		dmsOrderProduct.setCount(orderProduct.getCount());
		dmsOrderProduct.setType(orderProduct.getType());
		dmsOrderProduct.setCreatedDate(new Date());
		dmsOrderProduct.setCreatedBy(param.getCreatedBy());
		dmsOrderProduct.setRemoveFlag(0);
		dmsOrderProduct.setId(null);
		ykTrackOrderProductMapper.insertDmsOrderProduct(dmsOrderProduct);

		//在yk_track_order_product表中保存对应dms_order_product表的id
		YkTrackOrderProduct entity = new YkTrackOrderProduct();
		entity.setDmsId(dmsOrderProduct.getId());
		entity.setId(orderProduct.getId());
		ykTrackOrderProductMapper.updateByPrimaryKeySelective(entity);

	}		
					
					
					
					
	
	
	
 
